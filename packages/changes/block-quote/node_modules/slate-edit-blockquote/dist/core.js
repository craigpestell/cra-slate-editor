'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _options = require('./options');

var _options2 = _interopRequireDefault(_options);

var _utils = require('./utils');

var _changes = require('./changes');

var _validation = require('./validation');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * The core of the plugin, which does not relies on `slate-react`, and includes
 * everything but behavior and rendering logic.
 */
function core(optsParam) {
    var opts = new _options2.default(optsParam);

    return {
        schema: (0, _validation.schema)(opts),
        validateNode: (0, _validation.validateNode)(opts),

        utils: {
            isSelectionInBlockquote: _utils.isSelectionInBlockquote.bind(null, opts)
        },

        changes: {
            wrapInBlockquote: _changes.wrapInBlockquote.bind(null, opts),
            unwrapBlockquote: bindAndScopeChange(opts, _changes.unwrapBlockquote)
        }
    };
}

/**
 * Bind a change to given options, and scope it to act only inside a blockquote
 */
function bindAndScopeChange(opts, fn) {
    return function (change) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
        }

        var value = change.value;


        if (!(0, _utils.isSelectionInBlockquote)(opts, value)) {
            return change;
        }

        // $FlowFixMe
        return fn.apply(undefined, _toConsumableArray([opts, change].concat(args)));
    };
}

exports.default = core;